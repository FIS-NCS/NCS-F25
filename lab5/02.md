# Secret Detection

Secret detection involves analyzing application source code to identify leaked secrets such as passwords, API tokens, SSH identities, SSL certificates, encryption/decryption keys, and other sensitive information.

- Deleting a secret doesn't erase it from the commit history, and manipulating commit history is not an advisable solution, especially for repositories with multiple collaborators.
- A leaked secret should instead be invalidated as soon as possible (e.g., changing a password or revoking/renewing a token).

<details><summary>Recommended practices around secret management</summary>
<ul>
<li>Regulary rotate highly sensitive secrets</li>
<li> If secrets need to be stored remotely, use encryption at-rest and in-tranit.</li>
<li> In containerized environments: instead of baking secrets into the container file system, they can be injected in runtime into running containers that need them.</li>
<li> When providing secrets in CLI, prefer reading from files/stdin over specifying the secret in command arguments (to avoid leaks in shell history)</li>
<li> Logs from CI and other services may leak secrets, configure your monitoring system to match and redact such info, especially when generating reports.</li>
</ul>
</details><br>

## Practice

1. Initiailize a new repo

    ```bash
    mkdir project && cd project
    git init --initial-branch=main
    ```

1. Create a file `.env` with some sample secrets

    ```bash
    gitlab_token=glpat-JUST20LETTERSANDNUMB
    sha_256="3f306b76e92c8a8fbae88a3ef1c0f9b0a81fe3a953fa9320d5d0281b059887c3"
    rsa_id="-----BEGIN RSA PRIVATE KEY-----
    MIIJKQIBAAKCAgEAw7olVP8Mqd0qsrE8KLdLfB7CnP0pAaDYLfPeFr78WsQTSznH
    4rGQgcQV66ZJLbWOdMBSalu4+D9t3+2nze2jw5QC59/HyMXHLCv88knuSIva
    -----END RSA PRIVATE KEY-----"
    password="12232"
    api_token="ADB#@DC"
    ```

1. Commit the changes

    ```bash
    git add .env
    git config --global user.email "dev@example.com"
    git config --global user.name "dev"
    git commit -m "Add .env"
    ```

1. Delete the file and commit the changes

    ```bash
    git rm .env
    git add -A
    git commit -m "Delete .env"
    ```

1. Install and run [gitleaks](https://github.com/gitleaks/gitleaks) against the repository

    ```bash
    sudo apt install -y gitleaks
    gitleaks detect -v
    ```

## Exercise 2

> Goal: integrate secret detection in your CI/CD pipeline

1. How many secrets were detected by default in the demo above? Configure `gitleaks` to detect all of them.

1. Add a `.gitlab-ci.yml` to your repo that runs [Secret-Detection template](https://docs.gitlab.com/user/application_security/secret_detection/) against the codebase, have the generated report collected by GitLab as an artifact.

1. Test the CI, verify it runs on every push to the main branch and performs historical scans. Provide proof of the successful run of the pipeline under your account.

1. Configure a pre-commit hook with secret detection to prevent secrets from being committed to repositories in the first place. Test and verify it works.
